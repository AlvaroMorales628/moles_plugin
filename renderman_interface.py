import rfm2.ui.aov as aov
from rfm2.api.nodes import rman_default_display

from maya import cmds

# Credit to Brian Royston for advanced aov workflow and related code


""" FOR LIGHT GROUP AOVS """
def get_pxr_lights():
    pxr_light_types = cmds.listNodeTypes('rendernode/RenderMan/light')
    pxr_lights = cmds.ls(type=pxr_light_types)
    return pxr_lights

# pxrLights - List of strings of Pxr Lights
# Note: will return an empty list if there are lights that exist without an assigned light group
def get_light_groups(pxr_lights, active_lights_only = False):
    lgt_group_names = set()
    
    for light in pxr_lights:

        if (active_lights_only):
            transform_list = cmds.listRelatives(light, type='transform', parent=True, fullPath=True)
            
            # Both transform and shape node affect visibility of light for rendering
            # Hiding object with 'h' sets visibility of tranform node to 'Falmse' but not the shape node
            if (not cmds.getAttr(transform_list[0] + ".visibility") or not cmds.getAttr(light + ".visibility")):
                continue

        lgt_group_name = cmds.getAttr( light + ".lightGroup")
        lgt_group_names.add(lgt_group_name)
        
    return lgt_group_names

def create_lpe_aovs(lt_groups, dspy_name="rmanDefaultDisplay", advanced=False):

    sorted_lt_groups = sorted(lt_groups)
    sorted_lt_groups.append('emissive') # Has all emissives. Will cause error if there is a light group named 'emissive'
    for name in sorted_lt_groups:

        if (name == ""):
            continue

        if (not advanced):
            create_basic_lpe_channel(name, dspy_name)
        else:
            create_advance_lpe_channels(name, dspy_name)


def create_basic_lpe_channel(name, dspy_name):
    channel_name = "beauty_" + name
        
    aov.new_displaychannel(channel_name = channel_name,
                            config_name = "beauty",
                            dspy = dspy_name)
    src = "lpe:C[DS]*[<L.>]"
    cmds.setAttr(channel_name + '.channelSource', src, type="string")
    cmds.setAttr(channel_name + '.lpeLightGroup', name, type="string")

def create_advance_lpe_channels(name, dspy_name):
    diff_name = 'diffuse_' + name
    spec_name = 'specular_' + name
    
    if (name == 'emissive'): #Include O if this is the emissive channel
        diff_src = 'lpe:C(D[DS]*[LO])|[LO]'
        spec_src = 'lpe:CS[DS]*[LO]'
    else: # don't include O so that emissive isn't rendered as part of every light
        diff_src = 'lpe:C(D[DS]*[L])|[L]'
        spec_src = 'lpe:CS[DS]*[L]'
    
    aov.new_displaychannel(channel_name = diff_name,
                        config_name = 'diffuse',
                        dspy = dspy_name)
    
    aov.new_displaychannel(channel_name = spec_name,
                        config_name = 'specular',
                        dspy = dspy_name)
    
    cmds.setAttr(diff_name + '.channelSource', diff_src, type="string")
    cmds.setAttr(diff_name + '.lpeLightGroup', name, type="string")

    cmds.setAttr(spec_name + '.channelSource', spec_src, type="string")
    cmds.setAttr(spec_name + '.lpeLightGroup', name, type="string")


""" FOR BASIC AOVS """
# For creating aovs that having existing configs
def create_basic_aovs(aov_channels, dspy_name="rmanDefaultDisplay"):
    
    for channel in aov_channels:
        aov.new_displaychannel(channel_name = channel,
                                config_name = channel,
                                dspy = dspy_name)

""" UI RELATED """
def get_active_aov_ui():
    # Access the RenderMan AOV UI
    aov_ui = aov.LIVE_OBJECTS.get('URG_rmanGlobals_displaysConfigForm')
    return aov_ui 

def update_aov_ui():
    aov_ui = get_active_aov_ui()
    # if aovUI is none, the user hasn't opened the Renderman settings and there is nothing to update
    if (aov_ui):
        aov_ui.update()

""" GENERAL PURPOSE"""
def reset_aovs():
    all_displays = cmds.listConnections('rmanGlobals.displays', d=False, s=True, t='rmanDisplay')

    # Possible on brand new files where default display has not yet been created. Most likely it is possible to just create the default display ourselves in future
    if (all_displays == None):
        cmds.confirmDialog(title="Your file must be very fresh. Try opening the renderman settings before you continue using the plugin", button=["ok"])
        exit()

    for sel_node in all_displays:
        connected_nodes = cmds.listConnections(sel_node, s=True, d=False)
        if connected_nodes:
            for cnode in connected_nodes:
                cmds.delete(cnode)
        cmds.delete(sel_node)

    # Generate a default display. Default displays are always generated by ui updates but we are not interacting with ui objects here
    rman_default_display()
    
def createDisplay(dspy_name):
    all_displays = cmds.listConnections('rmanGlobals.displays', d=False, s=True, t='rmanDisplay')

    if (all_displays and dspy_name in all_displays):
        return
    
    aov.new_display(dspy_name = dspy_name, globals_node = 'rmanGlobals')

def setupDenoisedDisplay(dsp_name):
    cmds.setAttr(dsp_name + '.denoise', 1)
    cmds.setAttr(dsp_name + '.frameMode', 1)
    openExr = cmds.listConnections(dsp_name, type = 'd_openexr')[0]
    cmds.setAttr(openExr + '.asrgba', 0)

def add_cryptomatte():
    # add a cryptomatte filter if one doesn't already exist
    if (not cmds.listConnections('rmanGlobals.sampleFilters[0]')):
        cryptomatte = cmds.createNode('PxrCryptomatte')
        cmds.evalDeferred(lambda: cmds.connectAttr(cryptomatte + '.message', 'rmanGlobals.sampleFilters[0]', force=True))

def set_image_outputs():
    # Set image and rib outputs
    cmds.setAttr('rmanGlobals.imageFileFormat', '<scene>_<aov>.<f4>.<ext>', type='string')
    cmds.setAttr('rmanGlobals.ribFileFormat', '<scene>.<f4>.rib', type='string')

def warnings():
    # Warnings for other render setups
    if (cmds.getAttr('rmanGlobals.ocioConfig') != 1):
        conf = cmds.confirmDialog(title='Warning!', message='OCIO not set to ACES', button=['Set to ACES-1.2', 'Skip'])
        if (conf == 'Set to ACES-1.2'):
            cmds.setAttr('rmanGlobals.ocioConfig', 1)

    cameras = cmds.ls(type = 'camera')
    renderable_count = 0
    for camera_name in cameras:
        if (cmds.getAttr(camera_name + '.renderable')):
            renderable_count += 1
        
    if (renderable_count > 1):
        conf = cmds.confirmDialog(title='Warning!', message='You have more than one renderable camera', button=['Ok'])
    if (cmds.getAttr('defaultResolution.width') != 1920 or
        cmds.getAttr('defaultResolution.height') != 1080):
        conf = cmds.confirmDialog(title='Warning!', message='Resolution not set to 1920x1080', button=['Ok'])
    if ('<ws>' in cmds.getAttr('rmanGlobals.imageOutputDir')):
        conf = cmds.confirmDialog(title='Warning!', message='Image Output Directory set inside the workspace. Please save RIBs and Images outside of the shared drive', button=['Ok'])
    elif ('<ws' in cmds.getAttr('rmanGlobals.ribOutputDir')):
        conf = cmds.confirmDialog(title='Warning!', message='Image Output Directory set inside the workspace. Please save RIBs outside of the shared drive', button=['Ok'])

def check_for_renderman():
    return cmds.getAttr('defaultRenderGlobals.currentRenderer') == 'renderman'

def general_render_setup():
    # General Render Setup

    add_cryptomatte()
    set_image_outputs()
    #turn on 2D motion vectors
    cmds.setAttr('rmanGlobals.motionBlur', 2)

    warnings()



    